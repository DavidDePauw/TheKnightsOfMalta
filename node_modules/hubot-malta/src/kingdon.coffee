# Description:
#   Kingdon's callbacks
#
# Dependencies:
#   None
#
# Configuration:
#   None
#
# Commands:
#   tebot sup dawg - Receive a pug
#   hubot pug bomb N - get N pugs

flipFlop = (user, sta, par, job, mat, brn) ->
  if (sta == par)
    userstate2 = brn.get "state:#{user}:#{par}"
    if (userstate2 == null)
      brn.set "state:#{user}:#{par}", true
    else
      brn.set "state:#{user}:#{par}", null
      job mat

dumpObj = (obj) ->
  o = "{"
  for own key, value of obj
    v = value
    if key == "envelope" || key == "user" #|| key == "robot"
      v = dumpObj value
    o = o + "#{key}: #{v},"
  o = o + "}"

module.exports = (robot) ->

  robot.respond /sup dawg/i, (msg) ->
    msg.http("http://pugme.herokuapp.com/random")
      .get() (err, res, body) ->
        msg.send JSON.parse(body).pug

  robot.respond /save\s+(.*)/i, (res) ->
    robot.brain.set "memory:#{msg.envelope.user.name}", res.match[1]
    res.send "OK, got it."
    
  robot.respond /recall/i, (msg) ->
    memory = robot.brain.get "memory:#{msg.envelope.user.name}"
    msg.send memory

  robot.respond /dump\s*(.*)/i, (res) ->
    o = dumpObj res
    res.send o

  robot.hear /who am i/i, (msg) ->
    msg.send "You are @#{msg.envelope.user.name}!  Did you forget?"

  robot.respond /i have an idea/i, (msg) ->
    username = msg.envelope.user.name
    msg.send "What's your idea, #{username}?"
    robot.brain.set "state:#{username}", "has an idea"

  robot.hear ///(#{robot.name}.?\s+)?(.*)///, (res) ->
    username = res.envelope.user.name
    userstate = robot.brain.get "state:#{username}"
    match = res.match[2]

    parentState = "has an idea"
    doTheJob = (mat) ->
      robot.brain.set "ideas:#{username}", mat
      robot.brain.set "state:#{username}", ""
      res.send "Got it."
    flipFlop username, userstate, parentState, doTheJob, match, robot.brain

#  robot.brain.save "team-ideas:#{msg.envelope.user.name}", idea
